================
charmap
20 high 32 wide chardisplay

|32x20 bytes of chardisplay|256 char descrptions|256 bytes of palette|

640 ints in memory, after which 256 bytes of char data in memory.
    after which 256 bytes of palette
    each char in chardata is described by one int, lower 30 bits describe a 
    5 wide 6 high character.
    30 bits tsrqponmlkjihgfedcba9876543210 -> 
    01234
    56789
    abcde   if bit is set, pixel is foreground, unset -> background
    fghij
    klmno
    pqrst 
in chardisplay each int corresponds to 
8 lowest bits are the character
next 8 are foreground color index
next 8 are background color index
next 8 are effect (bit 0 = blink , rest are reserved)
=================
-testattu zero,rnd
-mmu vois testata ettei se riko mit채채n
-pic ja uartit testattaneen kerralla
keskeytykset
=================
-Pit채채 enabloida laitteesta ja picist채. 
-hypp채채 aina osoitteessa 0 olevaan osoitteeseen
-tekee k채yt채nn철ss채 parametrittoman CALLin eli palaaminen tapahtuu
 EXITill채. 
-keskeytys tapahtuu jos tulee "ennen채kem채t철n" 
 keskeytyksen nouseva reuna ja se keskeytys on 
 enabloidu ja kaikki keskeytykset ei ole disabloitu
-keskeytysk채sittelyrutiinista kannattaa tehd채 
 re-entrant ja disabloida keskeytykset heti 
 rutiiniin ment채ess채. 
-kun keskeytykset re-enabloidaan, "muistaa" pic 
 disabloinnin aikana tulleet keskeytykset ja 
 aiheuttaa keskeytyksen. 
 
 
irq         device
0           MMU reserved
1           UART1
2           UART2
3           VIC
4           RTC
5           SID

devicet
=================
-vanhat IN/OUT devicet muunnettiin geneerisemm채ksi
-lis채ttiin uusia esimerkkidevicej채. 

portti    device
0           CRT (writeonly, failaa jos lukee)
1           KBD (readonly, failaa jos lukee eik채 ole dataa,tai jos kirjottaa)
2           RES (varattu, failaa jos kosket)
3           RES
4           RES
5           RES
6           STDIN (readonly, failaa jos data loppuu tai jos kirjotat)
7           STDOUT (writeonly, failaa jos luet)
8           RES
9           RES
10          RES
11          ZERO (write /dev/null, read /dev/zero)
12          RND  (read to get (secure)random, write to set (PSR)seed)
13          MMU  (write 3 values to set from,to,length , or 0xffffffff to 
                  reset. Will map from,from+length of underlying memory to
                  to,to+length of visible memory)
14-17       RESMMU reserved for mmu magic
18-19       PIC  0 command port , 1 interrupt enable
                 0 read to get high interrupts
                 0 write 0->clear interrupts
                         1->disable all
                         2->re-enable
                 1 read to see enabled interrupts
                 1 write to set enabled , if you disable an interrupt it
                        will be cleared
20-22       UART1   0 data port 1 state port 2 control
23-25       UART2   see source code..
26-30       VIC     write 0 and new baseaddress to port 0
                    write 1 and new margincolor to port 0
                    write 2 and new mode to port 0 
                        (0=default 12 bit
                         1=text,with 256-char charmap just after the 
                           text data(640 ints),6 high 5 wide font
                           followed by a 256-color palette
                         2=8bit indexed,with 256-color palette in memory 
                           just after the image data)
31          RTC     watchdog/RTC counting processor clocks
                    write the number of clocks , it will count down
                    and then interrupt unless you rewrite. 0 will 
                    disable. reading will return clocks since reset.
32-33       SID     sound device , write 0 to port 0 for beep

Muutosloki v1.300
=================
Lis채ttiin titokoneeseen grafiikkatila.

(Toni Ruottu, 14.5.2012)

Muutosloki v1.203
=================
Kohahdus projekti teki titokoneeseen seuraavat muutokset

- RandomAccessMemory.setMemoryLine(..)
  Lis채tty "memory_references++;"

- RandomAccessMemory.getMemoryReferences()
  Lis채tty "- getCodeAreaSize() - getDataAreaSize()". N채m채 v채hent채v채t
  muistiviitelaskurista ohjelman latauksen aiheuttamat viitteet.

- Processor.subr(..)
  Lis채tty 2x "addToStack();" sek채 "stack_size--;"
  Lis채tty "stack_size = stack_size - param;"

- Control.run(..)
  Lis채tty "Throw new TTK91ExecutionOverrun(..)" jos steps liian iso

- Uusi luokka TTK91ExecutionOverrun


(Mikko Kinnunen 2006-11-23)


Muutosloki v1.202
=================

Poistettu graafisesta k채ytt철liittym채st채 turhaksi todettu k채채nn철s- ja
ajoaikainen hidaste, joka teki pitkien ohjelmien k채채nt채misest채 turhan 
tuskallista ("wait(70)"). 

Muutetut luokat: fi/hu/cs/titokone/GUIBrain.java

(Sini Ruohomaa, 14.12.2005)

Muutosloki v1.201
================

Korjattu taulukoiden alustukseen (DS) liittyv채 bugi, jossa
symbolitauluun vietiin virheellisi채 muistiosotteita. Muutettiin
luokkaa Compiler. Virheen kuvaus oli:

	DS ei toimi oikein eli esim.
	Tbl DS 5
	Xprt DC 0 
	niin Xprt symbolin arvoksi tullee Tbl+1

(Jari Suominen, 15.11.2005)


Muutosloki v1.2
===============

Alkuper채isen Koksi-ohjelman tuntema k채sky 'NOT' puuttui
Titokoneesta. Not k채sky lis채ttiin k채skykoodilla 27.

Titokoneen yhteydess채 esitelty uusi k채sky SHRA siirrettiin, koska
se k채ytti NOT-k채skylle varattua k채skykoodia. SHRA-k채skyn uusi koodi
on 28.

Nyt k채skyt LOAD/STORE R1, (R2) toimivat. Korjaus tapahtui lis채채m채채ll채 0 ennen 
alkavaa sulkua. STORE R1, @R2 toimii, korjaaminen tapahtui sallimalla 
@-osoitusmoodin k채ytt철 STORE k채skyn yhteydess채.

Lis채tty Titokoneeseen k채skylaskuri, jolla saadaan tieto suoritettujen
konek채skyjen m채채r채st채. Lis채tty metodi on nimelt채채n GiveCommAmount().

Lis채tty Titokoneeseen toiminto, jolla saadaan tieto pinon 
lopullisesta koosta. Lis채tty metodi on nimelt채채n GiveStackSize().

Lis채tty Titokoneeseen toiminto, jolla saadaan tieto ajettavana olevan
ohjelman lopullistesta koodisegmentin koosta. Lis채tty metodi on nimelt채채n 
getCodeAreaSize().

Lis채tty Titokoneeseen toiminto, jolla saadaan tieto ajettavana olevan
ohjelman lopullistesta datasegmentin koosta. Lis채tty metodi on nimelt채채n
getDataAreaSize().

(Koskelo-ryhm채 2004)


Muutosloki v1.1
===============

Titokoneesta on uusi versio 1.1. 
N채ytt채채 silt채, ett채 t채m채 Titokone pysyy pystyss채 Javan uusimmassa
buildissa (1.4.2_05) ja lis채ksi my철s ainakin Macin Java 1.4.1:ll채, jossa
oli aiemmin tiedostodialogia avatessa kaatumisen ongelma. Kaikkiaan noin
nelj채n rivin muutos, yksi Translator.javassa ja kolme GUI.javassa. 

Uusi versio on jo jakelussa. 
(Sini Ruohomaa, 23.8.2004)


Titokoneen piirteit채/ongelmia
=============================

Titokone 1.1b vaatii ainakin toistaisesti JRE 1.5:n, eli vanhemmat
versiot eiv채t toimi.
---
Nimett철m채t DC:t eiv채t toimi kuten ehk채 joku odottaisi. Esim.
    Pekka DC 0
          DC 2
          DC 4
antaa virheilmoituksia.

Koodin seassa pit채isi DC:t eiv채t toimi oikein. Ohjelman alussa 
olevat DC:t varataan lopusta ja keskell채 olevat siit채, miss채 ovat.
(Heikki Lindholm, 20.8.2004)
---
Animoinnissa ainakin joillakin koneilla suurin animointinopeus
on niin nopea, ett채 sit채 ei n채e!
(Teemu Kerola, 18.8.2004)
---
Exactumin luokalle B221 p채tee: l철ysin Sunin arkistoista version vanhemman 
javan (1.4.2_04). Testasin Titokonetta sill채 ja se n채ytti toimivan. 
Nyt vanha java on paketoitu ja pistetty asennukseen eli kun koneen 
boottaa se poistaa java 1.4.2_05:n ja asentaa 1.4.2_04:n.  

Kotikoneessa vanhempi java (sek채 sdk ett채 jre) l철ytyy osoitteesta
http://java.sun.com/products/archive/j2se/1.4.2_04/index.html
Kumpikaan paketti ei asenna javaa polkuun, joten se on teht채v채 k채sin, 
jotta titokone.bat skripti toimii.

Polku asetetaan seuraavasti:

Windows NT/2000/XP

Napsautetaan hiiren oikealla n채pp채imell채 My Computer-ikonia jolloin 
aukeaa harmaa laatikko josta valitaan vaihtoehto Properties. Nyt pit채isi 
olla auki System Properties-ikkuna. Valitaan sielt채 v채lilehti Advanced 
ja painetaan alhaalla olevaa Enviroment Variables nappia. Valitaan 
System variables listasta Path-muuttuja ja editoidaan siihen javan 
asennus hakemisto\bin, ja sen j채lkeen ;-merkki.

;-merkin teht채v채 on erottaa hakemistot toisistaan.

esim.
Alkuper채inen polku:
%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;

Uusi polku:
%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;C:\JavaSDK1.4.2\bin;

DOS tai Windows 95/98/ME

Avataan c:\autoexec.bat tekstieditoriin (esim. notepad). Etsit채채n rivi
set PATH=<t채ss채 on systeemin polku> ja editoidaan javan asennus 
hakemisto polun per채채n kuten yll채. T채m채n j채lkeen tallennetaan tiedosto 
ja k채ynnistet채채n kone uudelleen.

Windows NT/2000/XP:ss채 polku tulee voimaan seuraavaan k채ynnistettyyn 
komentorivitulkkiin, kun taas DOS tai Windows 95/98/ME on syyt채 k채ynnist채채 
uudelleen.

(Pasi Vettenranta, 17.8.2004)
---
Muisti ilmeisesti alustetaan aina suorituksen alussa.
DC-valek채skyill채 m채채ritellyt alustetaan arvonsa mukaisesti
ja DS-valek채skyill채 m채채ritellyt alueet nollataan.
Suorituksen alussa n채kyv채 data-alue ei n채yt채 n채it채 alustuksia.
(Teemu Kerola, 4.8.2004)

Raportoikaa muut uudet piirteet/ongelmat minulle, kiitos.
Teemu Kerola
-----------------bugeja.. 
-display pitais piilottaa jos alle x muistia tai sitten pist狎 se raa-asti
 toleroimaan muistin puutetta

Exception in thread "AWT-EventQueue-0" java.lang.ArrayIndexOutOfBoundsException: 2 >= 2
	at java.util.Vector.elementAt(Vector.java:447)
	at javax.swing.table.DefaultTableColumnModel.getColumn(DefaultTableColumnModel.java:294)
	at javax.swing.plaf.basic.BasicTableUI.paintCells(BasicTableUI.java:2006)
	at javax.swing.plaf.basic.BasicTableUI.paint(BasicTableUI.java:1806)
	at javax.swing.plaf.ComponentUI.update(ComponentUI.java:161)
	at javax.swing.JComponent.paintComponent(JComponent.java:765)
	at javax.swing.JComponent.paint(JComponent.java:1029)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JComponent.paint(JComponent.java:1038)
	at javax.swing.JViewport.paint(JViewport.java:764)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JComponent.paint(JComponent.java:1038)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JSplitPane.paintChildren(JSplitPane.java:1042)
	at javax.swing.JComponent.paint(JComponent.java:1038)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JComponent.paint(JComponent.java:1038)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JSplitPane.paintChildren(JSplitPane.java:1042)
	at javax.swing.JComponent.paint(JComponent.java:1038)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JComponent.paint(JComponent.java:1038)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JComponent.paint(JComponent.java:1038)
	at javax.swing.JLayeredPane.paint(JLayeredPane.java:581)
	at javax.swing.JComponent.paintChildren(JComponent.java:866)
	at javax.swing.JComponent.paintToOffscreen(JComponent.java:5145)
	at javax.swing.RepaintManager$PaintManager.paintDoubleBuffered(RepaintManager.java:1411)
	at javax.swing.RepaintManager$PaintManager.paint(RepaintManager.java:1342)
	at javax.swing.BufferStrategyPaintManager.paint(BufferStrategyPaintManager.java:318)
	at javax.swing.RepaintManager.paint(RepaintManager.java:1145)
	at javax.swing.JComponent.paint(JComponent.java:1015)
	at java.awt.GraphicsCallback$PaintCallback.run(GraphicsCallback.java:39)
	at sun.awt.SunGraphicsCallback.runOneComponent(SunGraphicsCallback.java:78)
	at sun.awt.SunGraphicsCallback.runComponents(SunGraphicsCallback.java:115)
	at java.awt.Container.paint(Container.java:1844)
	at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:751)
	at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:696)
	at javax.swing.RepaintManager.prePaintDirtyRegions(RepaintManager.java:676)
	at javax.swing.RepaintManager.access$700(RepaintManager.java:57)
	at javax.swing.RepaintManager$ProcessingRunnable.run(RepaintManager.java:1550)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:226)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:647)
	at java.awt.EventQueue.access$000(EventQueue.java:96)
	at java.awt.EventQueue$1.run(EventQueue.java:608)
	at java.awt.EventQueue$1.run(EventQueue.java:606)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:105)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:617)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:275)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:200)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:190)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:185)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:177)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:138)

